package producers

import (
	"fmt"
	amqp "github.com/rabbitmq/amqp091-go"
	"github.com/ysk229/go-rabbitmq/channels"
	"github.com/ysk229/go-rabbitmq/exchanges"
	"github.com/ysk229/go-rabbitmq/lib"
	"github.com/ysk229/go-rabbitmq/msg"
	"github.com/ysk229/go-rabbitmq/options"
	"log"
	"time"
)

type ProducerOpt struct {
	// Mandatory makes the publishing mandatory, which means when a queue is not
	// bound to the routing key a message will be sent back on the returns channel for you to handle.
	Mandatory bool
	// Immediate makes the publishing immediate, which means when a consumer is not available
	// to immediately handle the new message, a message will be sent back on the returns channel for you to handle.
	Immediate    bool
	DeliveryMode bool
	Exchange     string
	ExchangeType lib.ExchangeType
	RouteKey     string
}
type CallBack struct {
	Fnc         func(confirmed amqp.Confirmation)
	ResendDelay time.Duration //消息发送失败后，多久秒重发,默认是3s
	ResendNum   int           //消息重发次数
}

type ProducerOption func(*Producer)

type Producer struct {
	*channels.Channel
	publishSettings  *amqp.Publishing
	opt              *ProducerOpt
	cb               *CallBack
	reliable         bool
	notifyReturnChan chan amqp.Return
	confirmChan      chan amqp.Confirmation
	failChan         chan []ProducerOption
}

func NewProducer(ch *channels.Channel) *Producer {
	p := &Producer{Channel: ch}
	p.reliable = true
	return p
}

func WithOptionsProducer(opt *ProducerOpt) ProducerOption {
	return func(p *Producer) {
		p.opt = opt
	}
}
func WithOptionsProducerCallBack(cb *CallBack) ProducerOption {
	return func(p *Producer) {
		p.reliable = true
		if cb.ResendDelay == 0 {
			cb.ResendDelay = 3
		}
		p.cb = cb
	}
}

func WithOptionsPublishChannel(ch *channels.Channel) ProducerOption {
	return func(p *Producer) {
		p.Channel = ch
	}
}

func (p *Producer) Publish(msg *msg.Message,ch *channels.Channel, opts ...ProducerOption) {
	for _, opt := range opts {
		opt(p)
	}
	ch.Num = p.cb.ResendNum

	ch.SetConfirmChan(ch.ConfirmOne(make(chan amqp.Confirmation, 1)))
	ch.SetReturnChan(ch.NotifyReturn(make(chan amqp.Return, 1)))
	exchangeNum := 0
	queueNum := 0
	body := string(msg.Body)
	log.Println(body)
LOOKUP:
	for {
		if exchangeNum > p.cb.ResendNum || queueNum > p.cb.ResendNum {
			break LOOKUP
		}
		p.producer(msg,ch, opts...)
		select {
		case cf := <-ch.GetConfirmChan():
			if !cf.Ack {
				log.Println("exchange error  ", body)
				exchangeNum++
				log.Println(exchangeNum)
				if exchangeNum == p.cb.ResendNum+1 {
					log.Println("exchange fail data", body)
				}
			} else {
				select {
				case data := <-ch.GetReturnChan():
					queueNum++
					log.Println("queue error  data", body, "return data ,retry num", string(data.Body), queueNum)
					if queueNum == p.cb.ResendNum+1 {
						log.Println("queue fail data", body)
					}
				case <-time.After(1 * time.Second):
					log.Println("ok data", body)
					break LOOKUP

				}
			}
		}

		time.Sleep(p.cb.ResendDelay * time.Second)
	}

}


func (p *Producer) producer(msg *msg.Message,ch *channels.Channel, opts ...ProducerOption) {
	for _, opt := range opts {
		opt(p)
	}
	err := ch.Publish(p.opt.Exchange, p.opt.RouteKey,
		p.opt.Mandatory, // mandatory, true:若没有一个队列与交换器绑定，则将消息返还给生产者 , false:若交换器没有匹配到队列，消息直接丢弃
		p.opt.Immediate, // immediate , true:队列没有对应的消费者，则将消息返还给生产者,
		amqp.Publishing{
			ContentType:  msg.ContentType,
			Body:         msg.Body,
			DeliveryMode: msg.DeliveryMode,
			Headers:      lib.WrapTable(msg.Headers),
			Expiration:   msg.Expiration,
		},
	)

	if err != nil || ch.GetChannel().IsClosed() {
		log.Printf("%p Channel Publish %v err %v %p\n", ch, ch.GetChannel().IsClosed(), err, ch.GetChannel())
		p.reExchange(ch)
	}

}

func (p *Producer ) reExchange(ch *channels.Channel)  {
	if ch.GetChannel().IsClosed() {
		c := ch.GetChannel()
		_, _ = ch.NewChannel().Exchange(exchanges.NewExchange(&options.Exchange{ExchangeName: p.opt.Exchange, ExchangeType: p.opt.ExchangeType}))
		log.Println(fmt.Sprintf("旧的channel %p", c), "新的channel", fmt.Sprintf("%p", ch.GetChannel()))
		go ch.SetConfirmChan(ch.ConfirmOne(make(chan amqp.Confirmation, 1)))
		go ch.SetReturnChan(ch.NotifyReturn(make(chan amqp.Return, 1)))
	}
}
